<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BaseMeme Layer Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define Custom Colors */
        :root {
            --color-dark-bg: #302c44;
            --color-accent: #547cf4;
            --color-primary-action: #4362e5;
            --color-general-button: #a09bc5;
            --color-dark-accent: #0e1f72;
            --color-section-bg: #6f66a8;
            --color-white: #FFFFFF;
            --color-black: #000000;
        }

        /* --- LOCAL FONT LOADING --- */
        @font-face {
            font-family: 'AppGlobalFont';
            src: url('./fonts/font4.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont1';
            src: url('./fonts/font1.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont2';
            src: url('./fonts/font2.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont3';
            src: url('./fonts/font3.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* Base styles */
        body {
            font-family: 'AppGlobalFont', sans-serif;
            background-color: var(--color-dark-bg);
        }

        /* General Button Styling (omitted for brevity, assume they are carried over) */
        .control-button {
            transition: all 0.15s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: var(--color-black);
            background-color: var(--color-general-button);
        }
        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            background-color: #8c90b6;
        }
        .control-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .primary-action-button {
            background-color: var(--color-primary-action);
            color: var(--color-white);
        }
        .primary-action-button:hover {
            background-color: var(--color-dark-accent);
        }
        .selected-item {
            border-width: 4px;
            border-color: var(--color-accent) !important;
        }

        /* Scrollbar styles (omitted for brevity, assume they are carried over) */
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-thumb { background: var(--color-accent); border-radius: 4px; }
        #controls::-webkit-scrollbar-track { background: var(--color-dark-bg); }

        .canvas-container {
            /* Ensures the container respects max width/height */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Canvas z-index and interaction styles (omitted for brevity, assume they are carried over) */
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            cursor: default;
            pointer-events: none;
        }
        #drawingCanvas.active-drawing {
            pointer-events: auto;
            cursor: crosshair;
        }

        /* ---------------------------------------------------- */
        /* --- FIX: STICKY MENU AND STABLE CANVAS ON DESKTOP --- */
        /* ---------------------------------------------------- */
        @media (min-width: 1024px) {
            /* 1. Make the body take full height of the viewport on desktop */
            body {
                height: 100vh;
                overflow: hidden; /* Prevent main page scroll on desktop */
            }

            /* 2. Fix the control panel to the left, enabling internal scrolling */
            #controls {
                position: fixed !important; /* Override Tailwind's lg: order */
                top: 0;
                left: 0;
                height: 100vh;
                width: 33.3333%; /* lg:w-1/3 */
                overflow-y: auto; /* Enable internal scrolling */
                z-index: 20; /* Ensure it stays on top */
            }

            /* 3. Push the canvas content over by the width of the fixed sidebar */
            #preview-wrapper {
                margin-left: 33.3333%; /* 1/3 width offset */
                width: 66.6667%; /* lg:w-2/3 */
                min-height: 100vh; /* Takes remaining height */
                overflow-y: auto; /* In case the canvas content exceeds viewport height */

                /* Ensure the preview area is the primary scrollable content */
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
        }
        /* ---------------------------------------------------- */
    </style>
</head>
<body class="min-h-screen flex flex-col">

<div id="controls" class="w-full lg:w-1/3 bg-[--color-dark-bg] text-white p-4 lg:p-6 flex flex-col space-y-4 lg:space-y-6 order-2 lg:order-1 z-10">
    <h1 class="text-3xl font-extrabold text-[--color-accent] border-b border-[--color-accent] pb-3 mb-4">BaseMeme Layer Editor</h1>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">1. Upload Images</h2>
        <div class="flex flex-col space-y-2">
            <input type="file" id="imageUploadInput" accept="image/*" class="hidden" onchange="handleImageUpload(event)">

            <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'background';" class="primary-action-button control-button w-full py-2 font-bold rounded-lg">
                ‚¨ÜÔ∏è Upload & Set as Background
            </button>

            <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'layer';" class="primary-action-button control-button w-full py-2 font-bold rounded-lg">
                üñºÔ∏è Upload & Add as Layer (Movable/Rotatable)
            </button>
            <p class="text-sm text-gray-200">The layered image can be selected and edited below.</p>
        </div>
    </section>

    <hr class="border-[--color-accent]">

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">2. Template Background (Folder: /memes)</h2>
        <div id="templateSelector" class="grid grid-cols-3 gap-2">
        </div>
    </section>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">3. Add Sticker Item (Folder: /base)</h2>
        <div id="stickerSelector" class="grid grid-cols-3 gap-2">
        </div>
    </section>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">4. Drawing Tool (Paint)</h2>
        <div id="drawingControls" class="space-y-4 p-3 rounded-lg bg-[--color-section-bg] border border-[--color-accent]">

            <button id="drawingModeToggle" onclick="toggleDrawingMode()" class="control-button w-full py-2 font-bold rounded-lg bg-[--color-primary-action] text-white">
                üî¥ Toggle Drawing Mode (OFF)
            </button>

            <div class="flex items-center justify-between gap-3">
                <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                    <label for="drawColorInput" class="text-sm text-black cursor-pointer">Color:</label>
                    <input type="color" id="drawColorInput" value="#547cf4" class="w-8 h-8 rounded cursor-pointer" oninput="updateDrawingColor(event.target.value)">
                </div>

                <div class="flex items-center space-x-2">
                    <label for="drawSizeSelect" class="text-sm text-white">Size:</label>
                    <select id="drawSizeSelect" onchange="updateDrawingSize(event.target.value)" class="control-button p-2 rounded text-black">
                        <option value="5">Small</option>
                        <option value="15" selected>Medium</option>
                        <option value="30">Large</option>
                        <option value="50">Huge</option>
                    </select>
                </div>
            </div>

            <div>
                <label for="drawBrushSelect" class="text-sm text-white block mb-1">Brush Style:</label>
                <select id="drawBrushSelect" onchange="updateDrawingBrush(event.target.value)" class="control-button w-full p-2 rounded text-black">
                    <option value="line" selected>Line (Default)</option>
                    <option value="star">‚≠ê Star</option>
                    <option value="sparks">‚ú® Sparks</option>
                </select>
            </div>

            <button onclick="clearDrawingLayer()" class="control-button w-full py-2 rounded text-black font-bold">
                üßπ Clear Drawing Layer
            </button>
        </div>
    </section>

    <hr class="border-[--color-accent]">

    <section class="flex-grow pt-4">
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">5. Edit Selected Layer (<span id="currentLayerTypeDisplay">None</span>)</h2>

        <p class="text-sm text-gray-200 mb-2">Tap/click layer on image to edit. **(Must turn OFF Drawing Mode)**</p>

        <div id="contextualControls" class="space-y-4">

            <div id="textControls" class="space-y-4 hidden">
                <label for="currentTextContent" class="block text-sm font-medium text-white">Text Content</label>
                <textarea id="currentTextContent" rows="3" placeholder="Enter text content..." class="w-full p-2 rounded bg-white text-black border border-black focus:ring-[--color-accent] focus:border-[--color-accent] mt-1" oninput="updateCurrentTextContent()"></textarea>

                <div>
                    <span class="block text-sm font-medium text-white mb-1">Font Family (Folder: /fonts):</span>
                    <div id="fontSelector" class="flex flex-wrap gap-2"></div>
                </div>

                <div class="flex flex-wrap items-center gap-3 mb-4">
                    <button id="boldBtn" onclick="toggleStyle('isBold')" class="control-button px-3 py-2 rounded">
                        <span class="font-black">B</span>
                    </button>
                    <button id="italicBtn" onclick="toggleStyle('isItalic')" class="control-button px-3 py-2 rounded">
                        <span class="italic">I</span>
                    </button>

                    <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                        <label for="textColorInput" class="text-xs text-black cursor-pointer">Color:</label>
                        <input type="color" id="textColorInput" value="#ffffff" class="w-8 h-8 rounded cursor-pointer" oninput="updateTextColor()">
                    </div>
                </div>

                <div>
                    <span class="block text-sm font-medium text-white mb-1">Font Size:</span>
                    <select id="fontSizeSelect" onchange="updateFontSize()" class="control-button w-full p-2 rounded text-black">
                        <option value="40">Size: Small</option>
                        <option value="60" selected>Size: Medium</option>
                        <option value="80">Size: Large</option>
                        <option value="100">Size: Extra Large</option>
                        <option value="120">Size: Huge</option>
                    </select>
                </div>

                <h3 class="text-lg font-semibold text-white border-t border-[--color-accent] pt-3">Transformations</h3>
            </div>

            <div id="transformationControls" class="space-y-4 hidden">
                <div>
                    <label for="rotationSlider" class="block text-sm font-medium text-white">
                        Rotation: <span id="rotationValue">0¬∞</span>
                    </label>
                    <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateRotation(event.target.value)">
                </div>

                <div class="flex flex-wrap items-center gap-3">
                    <button id="flipXBtn" onclick="toggleFlip('flipX')" class="control-button px-3 py-2 rounded">
                        ‚ÜîÔ∏è Flip X (Mirror)
                    </button>
                    <button id="flipYBtn" onclick="toggleFlip('flipY')" class="control-button px-3 py-2 rounded">
                        ‚ÜïÔ∏è Flip Y
                    </button>
                </div>
            </div>

            <div id="imageControls" class="space-y-4 hidden">
                <label for="scaleSlider" class="block text-sm font-medium text-white">
                    Item Scale: <span id="scaleValue">100%</span>
                </label>
                <input type="range" id="scaleSlider" min="0.2" max="3" step="0.1" value="1.0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateItemScale(event.target.value)">
                <h3 class="text-lg font-semibold text-white border-t border-[--color-accent] pt-3">Transformations</h3>
            </div>

            <div id="commonControls" class="hidden">
                <button onclick="addTextLayer('NEW TEXT')" class="control-button w-full py-2 bg-[--color-accent] hover:bg-opacity-90 text-black font-bold rounded-lg mb-4">
                    ‚ûï Add New Text Layer
                </button>
                <button onclick="deleteSelectedLayer()" class="control-button w-full py-2 rounded bg-red-500 hover:bg-red-600 text-white font-bold">
                    üóëÔ∏è Delete Selected Layer
                </button>
            </div>
        </div>
    </section>

    <button onclick="downloadMeme()" class="primary-action-button control-button w-full py-3 font-bold rounded-lg shadow-lg mt-6">
        ‚¨áÔ∏è Download BaseMeme
    </button>
</div>

<div id="preview-wrapper" class="w-full order-1 lg:order-2">
    <div id="preview" class="w-full lg:w-full flex items-center justify-center p-4 lg:p-8 z-20 relative">
        <div class="bg-[--color-accent] p-2 lg:p-4 rounded-xl shadow-2xl max-w-full max-h-full canvas-container">
            <canvas id="memeCanvas" class="w-full h-full rounded-lg border-4 border-[--color-accent] bg-[--color-accent] shadow-xl touch-none"></canvas>
            <canvas id="drawingCanvas" class="rounded-lg touch-none"></canvas>
        </div>
    </div>
</div>

<script>
    // --- DATA DEFINITIONS (omitted for brevity) ---
    const templates = [
        { id: 't1', name: 'meme1.png', url: './memes/meme1.png', ratio: 4/3 },
        { id: 't2', name: 'meme2.png', url: './memes/meme2.png', ratio: 16/9 },
        { id: 't3', name: 'meme3.png', url: './memes/meme3.png', ratio: 3/4 },
        { id: 't4', name: 'meme4.png', url: './memes/meme4.png', ratio: 1/1 },
        { id: 't5', name: 'meme5.png', url: './memes/meme5.png', ratio: 9/5 },
        { id: 't6', name: 'meme6.png', url: './memes/meme6.png', ratio: 1/1 },
    ];

    const stickers = [
        { id: 's1', name: 'base1.png', url: './base/base1.png' },
        { id: 's2', name: 'base2.png', url: './base/base2.png' },
        { id: 's3', name: 'base3.png', url: './base/base3.png' },
        { id: 's4', name: 'base4.png', url: './base/base4.png' },
        { id: 's5', name: 'base5.png', url: './base/base5.png' },
        { id: 's6', name: 'base6.png', url: './base/base6.png' },
    ];

    const fonts = [
        { id: 'f4', name: 'font4.otf (Global)', family: 'AppGlobalFont', fallback: 'sans-serif' },
        { id: 'f1', name: 'font1.ttf', family: 'LocalFont1', fallback: 'sans-serif' },
        { id: 'f2', name: 'font2.ttf', family: 'LocalFont2', fallback: 'serif' },
        { id: 'f3', name: 'font3.ttf', family: 'LocalFont3', fallback: 'cursive' }
    ];

    // --- STATE MANAGEMENT ---
    const canvas = document.getElementById('memeCanvas');
    const ctx = canvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const MAX_CANVAS_WIDTH = 800;
    const MAX_CANVAS_HEIGHT = 800;

    let state = {
        selectedTemplateId: templates[0].id,
        currentTemplate: null,
        layers: [],
        selectedLayerIndex: -1,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        stickerImages: {},
        isDrawing: false,
        drawingMode: false,
        drawingColor: '#547cf4',
        drawingSize: 15,
        drawingBrush: 'line',
        lastX: 0,
        lastY: 0,
        isCustomBackground: false,
        uploadMode: 'background'
    };

    let initialTemplate = templates.find(t => t.id === state.selectedTemplateId);

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // ... (rest of initialization logic) ...
        renderTemplateSelector();
        renderStickerSelector();
        renderFontSelector();
        loadTemplateImage(initialTemplate.url, initialTemplate.ratio);

        // Initial text layers
        addTextLayer('TOP TEXT', MAX_CANVAS_WIDTH / 2, 0.1 * MAX_CANVAS_HEIGHT);
        addTextLayer('BOTTOM TEXT', MAX_CANVAS_WIDTH / 2, 0.9 * MAX_CANVAS_HEIGHT);

        // Set initial drawing controls
        document.getElementById('drawColorInput').value = state.drawingColor;
        document.getElementById('drawSizeSelect').value = state.drawingSize.toString();
        document.getElementById('drawBrushSelect').value = state.drawingBrush;

        document.fonts.ready.then(() => {
            drawMeme();
        }).catch(e => {
            console.warn("Issue loading local fonts.", e);
            drawMeme();
        });

        setupCanvasInteractions();
        setupDrawingInteractions();
        window.addEventListener('resize', resizeCanvases);
    });

    // --- (rest of JavaScript functions: resizeCanvases, toggleDrawingMode, render functions, layer manipulation, drawing, etc., remain the same) ---

    // Placeholder for remaining JS functions
    // Note: All functions from the previous response are needed here to ensure full functionality.

    function resizeCanvases() {
        if (canvas.width === 0 || canvas.height === 0) return;

        const previewElement = document.getElementById('preview');
        const containerRect = previewElement.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const canvasRatio = canvas.width / canvas.height;

        let renderWidth, renderHeight;

        if (containerWidth / containerHeight > canvasRatio) {
            renderHeight = containerHeight;
            renderWidth = containerHeight * canvasRatio;
        } else {
            renderWidth = containerWidth;
            renderHeight = containerWidth / canvasRatio;
        }

        canvas.style.width = `${renderWidth}px`;
        canvas.style.height = `${renderHeight}px`;
        drawingCanvas.style.width = `${renderWidth}px`;
        drawingCanvas.style.height = `${renderHeight}px`;

        drawingCanvas.width = canvas.width;
        drawingCanvas.height = canvas.height;

        updateDrawingContext();
    }

    // ... all other JS functions (drawMeme, loadTemplateImage, handleStart, startDrawing, etc.) ...

    function updateDrawingContext() {
        drawingCtx.lineCap = state.drawingBrush === 'line' ? 'round' : 'butt';
        drawingCtx.lineJoin = state.drawingBrush === 'line' ? 'round' : 'miter';
        drawingCtx.strokeStyle = state.drawingColor;
        drawingCtx.lineWidth = state.drawingSize;
    }

    function toggleDrawingMode() {
        state.drawingMode = !state.drawingMode;
        const button = document.getElementById('drawingModeToggle');

        if (state.drawingMode) {
            drawingCanvas.classList.add('active-drawing');
            button.textContent = 'üü¢ Toggle Drawing Mode (ON)';
            button.classList.remove('bg-[--color-primary-action]');
            button.classList.add('bg-red-500');
            state.selectedLayerIndex = -1; // Deselect layer
            updateControlPanel();
            drawMeme(); // Redraw layers without selection box
        } else {
            drawingCanvas.classList.remove('active-drawing');
            button.textContent = 'üî¥ Toggle Drawing Mode (OFF)';
            button.classList.add('bg-[--color-primary-action]');
            button.classList.remove('bg-red-500');
        }
    }

    function renderTemplateSelector() {
        const container = document.getElementById('templateSelector');
        container.innerHTML = templates.map(t => `
                <div
                    onclick="selectTemplate('${t.id}')"
                    class="control-button cursor-pointer p-1 rounded-lg border-2 border-transparent transition duration-150 ease-in-out ${state.selectedTemplateId === t.id && !state.isCustomBackground ? 'selected-item' : 'hover:border-[--color-accent] bg-[--color-general-button]'}"
                    data-id="${t.id}"
                >
                    <img src="${t.url}"
                         alt="${t.name}"
                         class="w-full h-auto object-cover rounded-md aspect-video"
                         onerror="this.onerror=null; this.src='https://placehold.co/150x85/1f2937/9ca3af?text=/${t.url.split('/')[1]}/Image'"
                    >
                    <p class="text-xs text-center mt-1 text-black">${t.name}</p>
                </div>
            `).join('');
    }

    function renderStickerSelector() {
        const container = document.getElementById('stickerSelector');
        container.innerHTML = stickers.map(s => `
                <div
                    onclick="addPresetImageLayer('${s.url}', '${s.id}')"
                    class="control-button cursor-pointer p-1 rounded-lg border-2 border-transparent hover:border-[--color-accent] transition duration-150 ease-in-out bg-[--color-general-button]"
                    data-id="${s.id}"
                >
                    <img src="${s.url}"
                         alt="${s.name}"
                         class="w-full h-auto object-cover rounded-md aspect-square"
                         onerror="this.onerror=null; this.src='https://placehold.co/150x150/1f2937/9ca3af?text=/${s.url.split('/')[1]}/Item'"
                    >
                    <p class="text-xs text-center mt-1 text-black">${s.name}</p>
                </div>
            `).join('');
    }

    function renderFontSelector() {
        const container = document.getElementById('fontSelector');
        container.innerHTML = fonts.map(f => `
                <button
                    onclick="selectFont('${f.id}')"
                    class="control-button px-3 py-1 text-sm rounded font-medium hover:bg-gray-200"
                    id="font-${f.id}"
                    style="font-family: '${f.family}', ${f.fallback};"
                >
                    ${f.name}
                </button>
            `).join('');
    }

    function updateControlPanel() {
        const index = state.selectedLayerIndex;
        const layer = state.layers[index];

        const textControls = document.getElementById('textControls');
        const imageControls = document.getElementById('imageControls');
        const commonControls = document.getElementById('commonControls');
        const transformationControls = document.getElementById('transformationControls');
        const layerTypeDisplay = document.getElementById('currentLayerTypeDisplay');

        textControls.classList.add('hidden');
        imageControls.classList.add('hidden');
        commonControls.classList.add('hidden');
        transformationControls.classList.add('hidden');
        layerTypeDisplay.textContent = 'None';

        if (index >= 0 && layer) {
            commonControls.classList.remove('hidden');
            transformationControls.classList.remove('hidden');

            document.getElementById('rotationSlider').value = layer.rotation;
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            document.getElementById('flipXBtn').classList.toggle('selected-item', layer.flipX);
            document.getElementById('flipYBtn').classList.toggle('selected-item', layer.flipY);

            if (layer.type === 'text') {
                layerTypeDisplay.textContent = `Text Layer ${index + 1}`;
                textControls.classList.remove('hidden');

                document.getElementById('currentTextContent').value = layer.content;
                document.getElementById('boldBtn').classList.toggle('selected-item', layer.isBold);
                document.getElementById('italicBtn').classList.toggle('selected-item', layer.isItalic);
                document.getElementById('fontSizeSelect').value = layer.fontSize.toString();
                document.getElementById('textColorInput').value = layer.color || '#FFFFFF';

                document.querySelectorAll('#fontSelector button').forEach(btn => {
                    btn.classList.remove('selected-item');
                    if (`font-${layer.fontId}` === btn.id) {
                        btn.classList.add('selected-item');
                    }
                });

            } else if (layer.type === 'image') {
                layerTypeDisplay.textContent = `Image/Sticker Layer ${index + 1}`;
                imageControls.classList.remove('hidden');

                document.getElementById('scaleSlider').value = layer.scale;
                document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            }
        }
    }

    function loadCustomTemplateImage(url) {
        state.isCustomBackground = true;
        renderTemplateSelector();

        const img = new Image();

        img.onload = () => {
            state.currentTemplate = img;

            let targetW = img.width;
            let targetH = img.height;

            if (targetW > MAX_CANVAS_WIDTH) {
                targetH = targetH * (MAX_CANVAS_WIDTH / targetW);
                targetW = MAX_CANVAS_WIDTH;
            }
            if (targetH > MAX_CANVAS_HEIGHT) {
                targetW = targetW * (MAX_CANVAS_HEIGHT / targetH);
                targetH = MAX_CANVAS_HEIGHT;
            }

            canvas.width = targetW;
            canvas.height = targetH;

            resizeCanvases();
            drawMeme();
        };
        img.onerror = () => {
            state.currentTemplate = null;
            state.isCustomBackground = false;
            console.error("Could not load custom image.");
            canvas.width = 600;
            canvas.height = 600;
            resizeCanvases();
            drawMeme();
        }
        img.src = url;
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const imageUrl = e.target.result;
            if (state.uploadMode === 'background') {
                loadCustomTemplateImage(imageUrl);
            } else if (state.uploadMode === 'layer') {
                addImageLayer(imageUrl, file.name);
            }
        };
        reader.readAsDataURL(file);
    }

    function selectTemplate(id) {
        state.selectedTemplateId = id;
        state.isCustomBackground = false;
        const selectedTemplate = templates.find(t => t.id === id);

        if (selectedTemplate) {
            renderTemplateSelector();
            loadTemplateImage(selectedTemplate.url, selectedTemplate.ratio);
        }
    }

    function addPresetImageLayer(url, id) {
        if (state.stickerImages[id]) {
            createImageLayerObject(url, state.stickerImages[id]);
            drawMeme();
        } else {
            const img = new Image();
            img.onload = () => {
                state.stickerImages[id] = img;
                createImageLayerObject(url, img);
                drawMeme();
            };
            img.onerror = () => {
                console.error("Could not load sticker image:", url);
            }
            img.src = url;
        }
    }

    function addImageLayer(url, name) {
        const img = new Image();
        img.onload = () => {
            createImageLayerObject(url, img, name);
            drawMeme();
        };
        img.onerror = () => {
            console.error("Could not load uploaded image:", name);
        }
        img.src = url;
    }

    function createImageLayerObject(url, imgObject, name = '') {
        const newLayer = {
            type: 'image',
            id: Date.now(),
            itemUrl: url,
            name: name,
            x: canvas.width / 2,
            y: canvas.height / 2,
            scale: 1.0,
            rotation: 0,
            flipX: false,
            flipY: false,
            imageObject: imgObject,
            originalW: imgObject.width,
            originalH: imgObject.height,
            bbox: { x: 0, y: 0, w: 0, h: 0 }
        };

        if (newLayer.originalW > canvas.width * 0.8 || newLayer.originalH > canvas.height * 0.8) {
            newLayer.scale = Math.min(
                (canvas.width * 0.8) / newLayer.originalW,
                (canvas.height * 0.8) / newLayer.originalH
            ) * 0.8;
        }

        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel();
    }

    function addTextLayer(content = 'New Text', x = MAX_CANVAS_WIDTH / 2, y = MAX_CANVAS_HEIGHT / 2) {
        const newLayer = {
            type: 'text',
            id: Date.now(),
            content: content.toUpperCase(),
            x: x,
            y: y,
            isBold: content.includes('TOP') || content.includes('BOTTOM') ? true : false,
            isItalic: false,
            fontSize: 60,
            color: '#FFFFFF',
            fontId: fonts[0].id,
            rotation: 0,
            flipX: false,
            flipY: false,
            bbox: { x: 0, y: 0, w: 0, h: 0 }
        };
        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel();
        drawMeme();
    }

    function deleteSelectedLayer() {
        if (state.selectedLayerIndex < 0) return;
        state.layers.splice(state.selectedLayerIndex, 1);
        state.selectedLayerIndex = -1;
        updateControlPanel();
        drawMeme();
    }

    function updateRotation(degrees) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer.rotation = parseInt(degrees);
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            drawMeme();
        }
    }

    function toggleFlip(axis) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer[axis] = !layer[axis];
            updateControlPanel();
            drawMeme();
        }
    }

    function selectFont(fontId) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.fontId = fontId;
            updateControlPanel();
            drawMeme();
        }
    }

    function toggleStyle(styleKey) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer[styleKey] = !layer[styleKey];
            updateControlPanel();
            drawMeme();
        }
    }

    function updateFontSize() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const size = document.getElementById('fontSizeSelect').value;
            layer.fontSize = parseInt(size);
            updateControlPanel();
            drawMeme();
        }
    }

    function updateCurrentTextContent() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const content = document.getElementById('currentTextContent').value;
            layer.content = content;
            drawMeme();
        }
    }

    function updateTextColor() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const color = document.getElementById('textColorInput').value;
            layer.color = color;
            drawMeme();
        }
    }

    function updateItemScale(scale) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'image') {
            layer.scale = parseFloat(scale);
            document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            drawMeme();
        }
    }

    function updateDrawingColor(color) {
        state.drawingColor = color;
        drawingCtx.strokeStyle = color;
        drawingCtx.fillStyle = color;
    }

    function updateDrawingSize(size) {
        state.drawingSize = parseInt(size);
        drawingCtx.lineWidth = state.drawingSize;
    }

    function updateDrawingBrush(brush) {
        state.drawingBrush = brush;
        updateDrawingContext();
    }

    function clearDrawingLayer() {
        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }

    function drawStar(x, y, size) {
        const r = size * 1.5;
        const points = 5;
        const innerR = r / 2;
        drawingCtx.fillStyle = state.drawingColor;
        drawingCtx.beginPath();
        for (let i = 0; i < points * 2; i++) {
            const radius = i % 2 === 0 ? r : innerR;
            const angle = (Math.PI / points) * i - (Math.PI / 2);
            const drawX = x + radius * Math.cos(angle);
            const drawY = y + radius * Math.sin(angle);
            if (i === 0) {
                drawingCtx.moveTo(drawX, drawY);
            } else {
                drawingCtx.lineTo(drawX, drawY);
            }
        }
        drawingCtx.closePath();
        drawingCtx.fill();
    }

    function drawSparks(x, y, size) {
        const numSparks = 5 + Math.floor(size / 5);
        const scatter = size * 2;
        drawingCtx.fillStyle = state.drawingColor;

        for (let i = 0; i < numSparks; i++) {
            const sparkX = x + (Math.random() - 0.5) * scatter;
            const sparkY = y + (Math.random() - 0.5) * scatter;
            const sparkSize = Math.random() * (size / 3) + 1;
            drawingCtx.beginPath();
            drawingCtx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
            drawingCtx.fill();
        }
    }

    function loadTemplateImage(url, ratio) {
        const img = new Image();

        img.onload = () => {
            state.currentTemplate = img;

            let targetW = img.width;
            let targetH = img.height;

            if (targetW > MAX_CANVAS_WIDTH) {
                targetH = targetH * (MAX_CANVAS_WIDTH / targetW);
                targetW = MAX_CANVAS_WIDTH;
            }
            if (targetH > MAX_CANVAS_HEIGHT) {
                targetW = targetW * (MAX_CANVAS_HEIGHT / targetH);
                targetH = MAX_CANVAS_HEIGHT;
            }

            canvas.width = targetW;
            canvas.height = targetH;

            const ratioX = canvas.width / MAX_CANVAS_WIDTH;
            const ratioY = canvas.height / MAX_CANVAS_HEIGHT;

            state.layers.forEach(layer => {
                layer.x = layer.x * ratioX;
                layer.y = layer.y * ratioY;
            });

            // Note: This is a hacky way to update constants, normally you'd use a variable.
            // Keeping it for consistency with the spirit of the previous code.
            window.MAX_CANVAS_WIDTH = canvas.width;
            window.MAX_CANVAS_HEIGHT = canvas.height;


            resizeCanvases();
            drawMeme();
        };
        img.onerror = () => {
            state.currentTemplate = null;
            console.error("Could not load template image:", url);

            canvas.width = 600;
            canvas.height = 600;

            resizeCanvases();
            drawMeme();
        }
        img.src = url;
    }

    function drawMeme() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.currentTemplate) {
            ctx.drawImage(state.currentTemplate, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#547cf4';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.font = '30px AppGlobalFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Template Missing or Failed to Load.', canvas.width / 2, canvas.height / 2);
        }

        state.layers.forEach((layer, index) => {
            const isSelected = index === state.selectedLayerIndex;
            if (layer.type === 'text') {
                drawTextLayer(layer, isSelected);
            } else if (layer.type === 'image' && layer.imageObject) {
                drawImageLayer(layer, isSelected);
            }
        });
    }

    function drawImageLayer(layer, isSelected) {
        if (!layer.imageObject) return;

        const scale = layer.scale;
        const drawW = layer.originalW * scale;
        const drawH = layer.originalH * scale;
        const padding = 5;

        ctx.save();
        ctx.translate(layer.x, layer.y);
        ctx.rotate(layer.rotation * Math.PI / 180);

        const flipX = layer.flipX ? -1 : 1;
        const flipY = layer.flipY ? -1 : 1;
        ctx.scale(flipX, flipY);

        ctx.drawImage(layer.imageObject, -drawW / 2, -drawH / 2, drawW, drawH);

        layer.bbox = {
            x: layer.x - drawW / 2 - padding,
            y: layer.y - drawH / 2 - padding,
            w: drawW + (padding * 2),
            h: drawH + (padding * 2),
            centerX: layer.x,
            centerY: layer.y,
            rotation: layer.rotation
        };

        if (isSelected) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#547cf4';
            ctx.lineWidth = 3;
            ctx.strokeRect(-drawW / 2 - padding, -drawH / 2 - padding, drawW + (padding * 2), drawH + (padding * 2));
            ctx.setLineDash([]);
        }

        ctx.restore();
    }

    function drawTextLayer(layer, isSelected) {
        const fontObj = fonts.find(f => f.id === layer.fontId);
        const fontBase = fontObj ? fontObj.family : fonts[0].family;

        let fontStyle = layer.isBold ? '900' : 'normal';
        if (layer.isItalic) fontStyle += ' italic';

        ctx.font = `${fontStyle} ${layer.fontSize}px ${fontBase}, ${fontObj.fallback}`;

        const maxWidth = canvas.width * 0.95;
        const lines = getLines(ctx, layer.content.toUpperCase(), maxWidth);
        const lineHeight = layer.fontSize * 1.2;
        const totalTextHeight = lines.length * lineHeight;

        let maxLineWidth = 0;
        lines.forEach(line => {
            const width = ctx.measureText(line).width;
            if (width > maxLineWidth) maxLineWidth = width;
        });

        const padding = 10;
        layer.bbox = {
            x: layer.x - (maxLineWidth / 2) - padding,
            y: layer.y - (totalTextHeight / 2) - padding,
            w: maxLineWidth + (padding * 2),
            h: totalTextHeight + (padding * 2),
            centerX: layer.x,
            centerY: layer.y,
            rotation: layer.rotation
        };

        ctx.save();
        ctx.translate(layer.x, layer.y);
        ctx.rotate(layer.rotation * Math.PI / 180);

        const flipX = layer.flipX ? -1 : 1;
        const flipY = layer.flipY ? -1 : 1;
        ctx.scale(flipX, flipY);

        ctx.strokeStyle = 'black';
        ctx.lineWidth = Math.floor(layer.fontSize * 0.08);
        ctx.fillStyle = layer.color || 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        let currentY = -(totalTextHeight / 2) + (lineHeight / 2);
        lines.forEach((line) => {
            ctx.strokeText(line, 0, currentY);
            ctx.fillText(line, 0, currentY);
            currentY += lineHeight;
        });

        if (isSelected) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#547cf4';
            ctx.lineWidth = 3;

            ctx.strokeRect(
                -maxLineWidth / 2 - padding,
                -totalTextHeight / 2 - padding,
                maxLineWidth + (padding * 2),
                totalTextHeight + (padding * 2)
            );
            ctx.setLineDash([]);
        }

        ctx.restore();
    }

    function getLines(ctx, text, maxWidth) {
        const words = text.split(" ");
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + " " + word).width;

            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    function getEventLocation(event, element) {
        const rect = element.getBoundingClientRect();
        let clientX, clientY;

        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else if (event.clientX !== undefined) {
            clientX = event.clientX;
            clientY = event.clientY;
        } else {
            return null;
        }

        const scaleX = element.width / rect.width;
        const scaleY = element.height / rect.height;

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function setupCanvasInteractions() {
        const startEvents = ['mousedown', 'touchstart'];
        const moveEvents = ['mousemove', 'touchmove'];
        const endEvents = ['mouseup', 'touchend', 'touchcancel'];

        startEvents.forEach(eventName => canvas.addEventListener(eventName, handleStart, false));
        moveEvents.forEach(eventName => canvas.addEventListener(eventName, handleMove, false));
        endEvents.forEach(eventName => canvas.addEventListener(eventName, handleEnd, false));
    }

    function checkHit(loc, bbox) {
        return loc.x >= bbox.x && loc.x <= bbox.x + bbox.w &&
            loc.y >= bbox.y && loc.y <= bbox.y + bbox.h;
    }

    function handleStart(event) {
        event.preventDefault();
        const loc = getEventLocation(event, canvas);
        if (!loc) return;

        let hitIndex = -1;
        for (let i = state.layers.length - 1; i >= 0; i--) {
            const layer = state.layers[i];
            if (checkHit(loc, layer.bbox)) {
                hitIndex = i;
                break;
            }
        }

        state.selectedLayerIndex = hitIndex;
        updateControlPanel();
        drawMeme();

        if (hitIndex !== -1) {
            state.isDragging = true;
            state.dragStartX = loc.x - state.layers[hitIndex].x;
            state.dragStartY = loc.y - state.layers[hitIndex].y;
        }
    }

    function handleMove(event) {
        if (!state.isDragging || state.selectedLayerIndex < 0) return;
        event.preventDefault();

        const loc = getEventLocation(event, canvas);
        if (!loc) return;

        const layer = state.layers[state.selectedLayerIndex];

        let newX = loc.x - state.dragStartX;
        let newY = loc.y - state.dragStartY;

        newX = Math.max(0, Math.min(newX, canvas.width));
        newY = Math.max(0, Math.min(newY, canvas.height));

        layer.x = newX;
        layer.y = newY;

        drawMeme();
    }

    function handleEnd(event) {
        if (state.isDragging) {
            event.preventDefault();
            state.isDragging = false;
            drawMeme();
        }
    }

    function setupDrawingInteractions() {
        updateDrawingContext();

        const startEvents = ['mousedown', 'touchstart'];
        const moveEvents = ['mousemove', 'touchmove'];
        const endEvents = ['mouseup', 'touchend', 'touchcancel'];

        startEvents.forEach(eventName => drawingCanvas.addEventListener(eventName, startDrawing, false));
        moveEvents.forEach(eventName => drawingCanvas.addEventListener(eventName, draw, false));
        endEvents.forEach(eventName => drawingCanvas.addEventListener(eventName, stopDrawing, false));
    }

    function startDrawing(event) {
        if (!state.drawingMode) return;
        event.preventDefault();
        state.isDrawing = true;

        const loc = getEventLocation(event, drawingCanvas);
        if (!loc) return;

        [state.lastX, state.lastY] = [loc.x, loc.y];

        if (state.drawingBrush === 'star') {
            drawStar(loc.x, loc.y, state.drawingSize);
            stopDrawing();
            return;
        } else if (state.drawingBrush === 'sparks') {
            drawSparks(loc.x, loc.y, state.drawingSize);
            stopDrawing();
            return;
        }

        drawingCtx.beginPath();
        drawingCtx.moveTo(loc.x, loc.y);
    }

    function draw(event) {
        if (!state.isDrawing || state.drawingBrush !== 'line') return;
        event.preventDefault();

        const loc = getEventLocation(event, drawingCanvas);
        if (!loc) return;

        drawingCtx.lineTo(loc.x, loc.y);
        drawingCtx.stroke();

        [state.lastX, state.lastY] = [loc.x, loc.y];
    }

    function stopDrawing() {
        state.isDrawing = false;
        if (state.drawingBrush === 'line') {
            drawingCtx.closePath();
        }
    }

    function downloadMeme() {
        if (!state.currentTemplate) {
            console.error('Download Error: Please select a Template or upload an image first.');
            return;
        }

        const originalSelection = state.selectedLayerIndex;
        state.selectedLayerIndex = -1;
        drawMeme();

        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = canvas.width;
        finalCanvas.height = canvas.height;
        const finalCtx = finalCanvas.getContext('2d');

        finalCtx.drawImage(canvas, 0, 0);
        finalCtx.drawImage(drawingCanvas, 0, 0);

        const dataURL = finalCanvas.toDataURL('image/png');

        state.selectedLayerIndex = originalSelection;
        drawMeme();

        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'BaseMeme_' + Date.now() + '.png';

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
</script>

</body>
</html>
