<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BaseMeme Layer Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">

    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }

        /* --- LOCAL FONT LOADING FROM /fonts FOLDER --- */
        /* To add font4.ttf, you would add a similar @font-face rule here */
        @font-face {
            font-family: 'LocalFont1';
            src: url('./fonts/font1.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont2';
            src: url('./fonts/font2.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont3';
            src: url('./fonts/font3.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        .control-button {
            transition: all 0.15s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            transform: translateY(-1px);
        }
        .control-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .selected-item {
            border-width: 4px;
            border-color: #3b82f6 !important;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-thumb { background: #374151; border-radius: 4px; }
        #controls::-webkit-scrollbar-track { background: #1f2937; }

        .canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        @media (max-width: 1024px) {
            #preview {
                min-height: 400px;
            }
        }

        /* Color input styling */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            padding: 0;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col lg:flex-row">

<!-- Left Panel: Controls -->
<div id="controls" class="w-full lg:w-1/3 bg-gray-900 text-white p-4 lg:p-6 overflow-y-auto flex flex-col space-y-4 lg:space-y-6 order-2 lg:order-1">
    <h1 class="text-3xl font-extrabold text-blue-400 border-b border-gray-700 pb-3 mb-4">BaseMeme Layer Editor</h1>

    <!-- 1. Select Template (Background) from /memes -->
    <section>
        <h2 class="text-xl font-bold mb-3 text-blue-300">1. Template Background (Folder: /memes)</h2>
        <div id="templateSelector" class="grid grid-cols-3 gap-2">
            <!-- Templates will be rendered here -->
        </div>
    </section>

    <!-- 2. Add Sticker Item from /base -->
    <section>
        <h2 class="text-xl font-bold mb-3 text-blue-300">2. Add Sticker Item (Folder: /base)</h2>
        <div id="stickerSelector" class="grid grid-cols-3 gap-2">
            <!-- Stickers will be rendered here -->
        </div>
    </section>

    <!-- 3. Layer Management & Customization -->
    <section class="flex-grow border-t border-gray-700 pt-4">
        <h2 class="text-xl font-bold mb-3 text-blue-300">3. Edit Selected Layer (<span id="currentLayerTypeDisplay">None</span>)</h2>

        <p class="text-sm text-gray-400 mb-2">Tap/click layer on image to edit.</p>

        <!-- Container for Contextual Controls -->
        <div id="contextualControls" class="space-y-4">

            <!-- --- Text Controls (Visible if text layer selected) --- -->
            <div id="textControls" class="space-y-4 hidden">
                <label for="currentTextContent" class="block text-sm font-medium text-gray-300">Text Content</label>
                <textarea id="currentTextContent" rows="3" placeholder="Enter text content..." class="w-full p-2 rounded bg-gray-700 border border-gray-600 text-white focus:ring-blue-500 focus:border-blue-500 mt-1" oninput="updateCurrentTextContent()"></textarea>

                <div>
                    <span class="block text-sm font-medium text-gray-300 mb-1">Font Family (Folder: /fonts):</span>
                    <div id="fontSelector" class="flex flex-wrap gap-2"></div>
                </div>

                <!-- Style Row 1: Bold, Italic, Color -->
                <div class="flex flex-wrap items-center gap-3 mb-4">
                    <button id="boldBtn" onclick="toggleStyle('isBold')" class="control-button px-3 py-2 rounded bg-gray-700 text-gray-300 hover:bg-gray-600">
                        <span class="font-black">B</span>
                    </button>
                    <button id="italicBtn" onclick="toggleStyle('isItalic')" class="control-button px-3 py-2 rounded bg-gray-700 text-gray-300 hover:bg-gray-600">
                        <span class="italic">I</span>
                    </button>

                    <!-- Color Picker -->
                    <div class="flex items-center space-x-2 bg-gray-700 rounded px-2 py-1 border border-gray-600">
                        <label for="textColorInput" class="text-xs text-gray-300 cursor-pointer">Color:</label>
                        <input type="color" id="textColorInput" value="#ffffff" class="w-8 h-8 rounded cursor-pointer" oninput="updateTextColor()">
                    </div>
                </div>

                <!-- Style Row 2: Size -->
                <div>
                    <span class="block text-sm font-medium text-gray-300 mb-1">Font Size:</span>
                    <select id="fontSizeSelect" onchange="updateFontSize()" class="control-button w-full p-2 rounded bg-gray-700 border border-gray-600 text-white">
                        <option value="40">Size: Small</option>
                        <option value="60" selected>Size: Medium</option>
                        <option value="80">Size: Large</option>
                        <option value="100">Size: Extra Large</option>
                        <option value="120">Size: Huge</option>
                    </select>
                </div>

                <h3 class="text-lg font-semibold text-gray-300 border-t border-gray-700 pt-3">Transformations</h3>
            </div>

            <!-- --- Common Transformation Controls (Visible for both text and image) --- -->
            <div id="transformationControls" class="space-y-4 hidden">
                <!-- Rotation Slider -->
                <div>
                    <label for="rotationSlider" class="block text-sm font-medium text-gray-300">
                        Rotation: <span id="rotationValue">0¬∞</span>
                    </label>
                    <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg" oninput="updateRotation(event.target.value)">
                </div>

                <!-- Flip Buttons -->
                <div class="flex flex-wrap items-center gap-3">
                    <button id="flipXBtn" onclick="toggleFlip('flipX')" class="control-button px-3 py-2 rounded bg-gray-700 text-gray-300 hover:bg-gray-600">
                        ‚ÜîÔ∏è Flip X (Mirror)
                    </button>
                    <button id="flipYBtn" onclick="toggleFlip('flipY')" class="control-button px-3 py-2 rounded bg-gray-700 text-gray-300 hover:bg-gray-600">
                        ‚ÜïÔ∏è Flip Y
                    </button>
                </div>
            </div>

            <!-- --- Sticker Controls (Visible if image layer selected) --- -->
            <div id="imageControls" class="space-y-4 hidden">
                <label for="scaleSlider" class="block text-sm font-medium text-gray-300">
                    Item Scale: <span id="scaleValue">100%</span>
                </label>
                <input type="range" id="scaleSlider" min="0.2" max="3" step="0.1" value="1.0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg" oninput="updateItemScale(event.target.value)">
                <h3 class="text-lg font-semibold text-gray-300 border-t border-gray-700 pt-3">Transformations</h3>
            </div>

            <!-- Always visible controls for selected layer -->
            <div id="commonControls" class="hidden">
                <button onclick="addTextLayer('NEW TEXT')" class="control-button w-full py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg mb-4">
                    ‚ûï Add New Text Layer
                </button>
                <button onclick="deleteSelectedLayer()" class="control-button w-full py-2 rounded bg-red-600 hover:bg-red-700 text-white font-bold">
                    üóëÔ∏è Delete Selected Layer
                </button>
            </div>
        </div>
    </section>

    <!-- Action Button -->
    <button onclick="downloadMeme()" class="control-button w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg mt-6">
        ‚¨áÔ∏è Download BaseMeme
    </button>
</div>

<!-- Right Panel: Canvas/Meme Preview -->
<div id="preview" class="w-full lg:w-2/3 flex items-center justify-center p-4 lg:p-8 order-1 lg:order-2">
    <div class="bg-gray-800 p-2 lg:p-4 rounded-xl shadow-2xl max-w-full max-h-full canvas-container">
        <canvas id="memeCanvas" class="w-full h-full rounded-lg border-4 border-gray-700 bg-black shadow-xl touch-none"></canvas>
    </div>
</div>

<script>
    // --- DATA DEFINITIONS: USING LOCAL FILE PATHS ---

    // Templates (Backgrounds), from the /memes folder
    const templates = [
        { id: 't1', name: 'meme1.png', url: './memes/meme1.png', ratio: 4/3 },
        { id: 't2', name: 'meme2.png', url: './memes/meme2.png', ratio: 16/9 },
        { id: 't3', name: 'meme3.png', url: './memes/meme3.png', ratio: 3/4 },
        { id: 't4', name: 'meme4.png', url: './memes/meme4.png', ratio: 1/1 },
        { id: 't5', name: 'meme5.png', url: './memes/meme5.png', ratio: 9/5 },
        { id: 't6', name: 'meme6.png', url: './memes/meme6.png', ratio: 1/1 },
        // If you add meme7.png to the /memes folder, register it here:
        // { id: 't7', name: 'meme7.png', url: './memes/meme7.png', ratio: 1/1 },
    ];

    // Stickers/Items, from the /base folder
    const stickers = [
        { id: 's1', name: 'base1.png', url: './base/base1.png' },
        { id: 's2', name: 'base2.png', url: './base/base2.png' },
        { id: 's3', name: 'base3.png', url: './base/base3.png' },
        { id: 's4', name: 'base4.png', url: './base/base4.png' },
        { id: 's5', name: 'base5.png', url: './base/base5.png' },
        { id: 's6', name: 'base6.png', url: './base/base6.png' },
        // If you add base7.png to the /base folder, register it here:
        // { id: 's7', name: 'base7.png', url: './base/base7.png' },
    ];

    // Fonts, from the /fonts folder, mapped to CSS font-family names
    const fonts = [
        { id: 'f1', name: 'font1.ttf', family: 'LocalFont1', fallback: 'sans-serif' },
        { id: 'f2', name: 'font2.ttf', family: 'LocalFont2', fallback: 'serif' },
        { id: 'f3', name: 'font3.ttf', family: 'LocalFont3', fallback: 'cursive' }
        // If you add font4.ttf to the /fonts folder, register it here:
        // { id: 'f4', name: 'font4.ttf', family: 'LocalFont4', fallback: 'sans-serif' },
    ];

    // --- STATE MANAGEMENT ---

    const canvas = document.getElementById('memeCanvas');
    const ctx = canvas.getContext('2d');
    const MAX_CANVAS_WIDTH = 800;
    const MAX_CANVAS_HEIGHT = 800;

    let state = {
        selectedTemplateId: templates[0].id,
        currentTemplate: null, // Holds the Image object for the background
        layers: [], // Array of ALL layers (text or image)
        selectedLayerIndex: -1,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        scaleFactor: 1,
        stickerImages: {} // Cache for loaded sticker images
    };

    let initialTemplate = templates.find(t => t.id === state.selectedTemplateId);

    // --- INITIALIZATION ---

    document.addEventListener('DOMContentLoaded', () => {
        renderTemplateSelector();
        renderStickerSelector();
        renderFontSelector();
        loadTemplateImage(initialTemplate.url, initialTemplate.ratio);

        // Add two default text layers
        addTextLayer('TOP TEXT', MAX_CANVAS_WIDTH / 2, 0.1 * MAX_CANVAS_HEIGHT);
        addTextLayer('BOTTOM TEXT', MAX_CANVAS_WIDTH / 2, 0.9 * MAX_CANVAS_HEIGHT);

        // Ensure fonts are loaded before drawing (best effort for local files)
        document.fonts.ready.then(() => {
            drawMeme();
        }).catch(e => {
            console.warn("Issue loading local fonts.", e);
            drawMeme();
        });

        setupCanvasInteractions();
        window.addEventListener('resize', calculateScaleFactor);
    });

    function calculateScaleFactor() {
        const rect = canvas.getBoundingClientRect();
        if (canvas.width > 0 && rect.width > 0) {
            state.scaleFactor = canvas.width / rect.width;
            drawMeme();
        }
    }

    // --- RENDERING CONTROLS ---

    function renderFontSelector() {
        const container = document.getElementById('fontSelector');
        container.innerHTML = fonts.map(f => `
                <button
                    onclick="selectFont('${f.id}')"
                    class="control-button px-3 py-1 text-sm rounded font-medium bg-gray-700 text-gray-300 hover:bg-gray-600"
                    id="font-${f.id}"
                    style="font-family: '${f.family}', ${f.fallback};"
                >
                    ${f.name}
                </button>
            `).join('');
    }

    function renderTemplateSelector() {
        const container = document.getElementById('templateSelector');
        container.innerHTML = templates.map(t => `
                <div
                    onclick="selectTemplate('${t.id}')"
                    class="control-button cursor-pointer p-1 rounded-lg border-2 border-gray-700 transition duration-150 ease-in-out ${state.selectedTemplateId === t.id ? 'selected-item' : 'hover:border-blue-500'}"
                    data-id="${t.id}"
                >
                    <img src="${t.url}"
                         alt="${t.name}"
                         class="w-full h-auto object-cover rounded-md aspect-video"
                         onerror="this.onerror=null; this.src='https://placehold.co/150x85/1f2937/9ca3af?text=/${t.url.split('/')[1]}/Image'"
                    >
                    <p class="text-xs text-center mt-1 text-gray-300">${t.name}</p>
                </div>
            `).join('');
    }

    function renderStickerSelector() {
        const container = document.getElementById('stickerSelector');
        container.innerHTML = stickers.map(s => `
                <div
                    onclick="addStickerLayer('${s.url}', '${s.id}')"
                    class="control-button cursor-pointer p-1 rounded-lg border-2 border-gray-700 hover:border-blue-500 transition duration-150 ease-in-out"
                    data-id="${s.id}"
                >
                    <img src="${s.url}"
                         alt="${s.name}"
                         class="w-full h-auto object-cover rounded-md aspect-square"
                         onerror="this.onerror=null; this.src='https://placehold.co/150x150/1f2937/9ca3af?text=/${s.url.split('/')[1]}/Item'"
                    >
                    <p class="text-xs text-center mt-1 text-gray-300">${s.name}</p>
                </div>
            `).join('');
    }

    function updateControlPanel() {
        const index = state.selectedLayerIndex;
        const layer = state.layers[index];

        const textControls = document.getElementById('textControls');
        const imageControls = document.getElementById('imageControls');
        const commonControls = document.getElementById('commonControls');
        const transformationControls = document.getElementById('transformationControls');
        const layerTypeDisplay = document.getElementById('currentLayerTypeDisplay');

        // Hide all controls by default
        textControls.classList.add('hidden');
        imageControls.classList.add('hidden');
        commonControls.classList.add('hidden');
        transformationControls.classList.add('hidden');
        layerTypeDisplay.textContent = 'None';

        if (index >= 0 && layer) {
            commonControls.classList.remove('hidden');
            transformationControls.classList.remove('hidden'); // Transformations are common

            // Set transformation controls
            document.getElementById('rotationSlider').value = layer.rotation;
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            document.getElementById('flipXBtn').classList.toggle('selected-item', layer.flipX);
            document.getElementById('flipYBtn').classList.toggle('selected-item', layer.flipY);

            if (layer.type === 'text') {
                layerTypeDisplay.textContent = `Text Layer ${index + 1}`;
                textControls.classList.remove('hidden');

                // Populate text controls
                document.getElementById('currentTextContent').value = layer.content;
                document.getElementById('boldBtn').classList.toggle('selected-item', layer.isBold);
                document.getElementById('italicBtn').classList.toggle('selected-item', layer.isItalic);
                document.getElementById('fontSizeSelect').value = layer.fontSize.toString();
                document.getElementById('textColorInput').value = layer.color || '#FFFFFF';

                document.querySelectorAll('#fontSelector button').forEach(btn => {
                    btn.classList.remove('selected-item');
                    if (`font-${layer.fontId}` === btn.id) {
                        btn.classList.add('selected-item');
                    }
                });

            } else if (layer.type === 'image') {
                layerTypeDisplay.textContent = `Sticker/Item Layer ${index + 1}`;
                imageControls.classList.remove('hidden');

                // Populate image controls
                document.getElementById('scaleSlider').value = layer.scale;
                document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            }
        }
    }


    // --- USER INTERACTIONS (CONTROLS) ---

    function selectTemplate(id) {
        state.selectedTemplateId = id;
        const selectedTemplate = templates.find(t => t.id === id);

        if (selectedTemplate) {
            renderTemplateSelector();
            loadTemplateImage(selectedTemplate.url, selectedTemplate.ratio);
        }
    }

    function addTextLayer(content = 'New Text', x = MAX_CANVAS_WIDTH / 2, y = MAX_CANVAS_HEIGHT / 2) {
        const newLayer = {
            type: 'text',
            id: Date.now(),
            content: content.toUpperCase(),
            x: x,
            y: y,
            isBold: content.includes('TOP') || content.includes('BOTTOM') ? true : false,
            isItalic: false,
            fontSize: 60,
            color: '#FFFFFF',
            fontId: fonts[0].id,
            rotation: 0, // NEW
            flipX: false, // NEW (Mirror)
            flipY: false, // NEW
            bbox: { x: 0, y: 0, w: 0, h: 0 }
        };
        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel();
        drawMeme();
    }

    function addStickerLayer(url, id) {
        const newLayer = {
            type: 'image',
            id: Date.now(),
            itemUrl: url,
            x: MAX_CANVAS_WIDTH / 2,
            y: MAX_CANVAS_HEIGHT / 2,
            scale: 1.0,
            rotation: 0, // NEW
            flipX: false, // NEW (Mirror)
            flipY: false, // NEW
            imageObject: null,
            originalW: 100,
            originalH: 100,
            bbox: { x: 0, y: 0, w: 0, h: 0 }
        };

        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel();

        // Load the image if not already cached
        if (state.stickerImages[id]) {
            newLayer.imageObject = state.stickerImages[id];
            newLayer.originalW = newLayer.imageObject.width;
            newLayer.originalH = newLayer.imageObject.height;
            drawMeme();
        } else {
            const img = new Image();
            img.onload = () => {
                state.stickerImages[id] = img;
                newLayer.imageObject = img;
                newLayer.originalW = img.width;
                newLayer.originalH = img.height;
                drawMeme();
            };
            img.onerror = () => {
                console.error("Could not load sticker image:", url);
                state.layers.pop(); // Remove layer if image fails to load
                state.selectedLayerIndex = -1;
                updateControlPanel();
            }
            img.src = url;
        }
    }

    function deleteSelectedLayer() {
        if (state.selectedLayerIndex < 0) return;

        state.layers.splice(state.selectedLayerIndex, 1);
        state.selectedLayerIndex = -1;
        updateControlPanel();
        drawMeme();
    }

    // --- Transformation Control Handlers ---
    function updateRotation(degrees) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer.rotation = parseInt(degrees);
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            drawMeme();
        }
    }

    function toggleFlip(axis) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer[axis] = !layer[axis];
            updateControlPanel(); // Update button visual state
            drawMeme();
        }
    }

    // --- Text Control Handlers ---
    function selectFont(fontId) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.fontId = fontId;
            updateControlPanel();
            drawMeme();
        }
    }

    function toggleStyle(styleKey) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer[styleKey] = !layer[styleKey];
            updateControlPanel();
            drawMeme();
        }
    }

    function updateFontSize() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const size = document.getElementById('fontSizeSelect').value;
            layer.fontSize = parseInt(size);
            updateControlPanel();
            drawMeme();
        }
    }

    function updateCurrentTextContent() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const content = document.getElementById('currentTextContent').value;
            layer.content = content;
            drawMeme();
        }
    }

    function updateTextColor() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            const color = document.getElementById('textColorInput').value;
            layer.color = color;
            drawMeme();
        }
    }

    // --- Image Control Handler ---
    function updateItemScale(scale) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'image') {
            layer.scale = parseFloat(scale);
            document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            drawMeme();
        }
    }

    // --- CANVAS LOGIC: IMAGE LOADING ---

    function loadTemplateImage(url, ratio) {
        const img = new Image();

        img.onload = () => {
            state.currentTemplate = img;

            // Set canvas size based on loaded image dimensions, constrained by MAX size
            let targetW = img.width;
            let targetH = img.height;

            if (targetW > MAX_CANVAS_WIDTH) {
                targetH = targetH * (MAX_CANVAS_WIDTH / targetW);
                targetW = MAX_CANVAS_WIDTH;
            }
            if (targetH > MAX_CANVAS_HEIGHT) {
                targetW = targetW * (MAX_CANVAS_HEIGHT / targetH);
                targetH = MAX_CANVAS_HEIGHT;
            }

            canvas.width = targetW;
            canvas.height = targetH;

            // Adjust the display size for responsive behavior
            const templateRatio = targetH / targetW;
            canvas.style.width = '100%';
            canvas.style.height = `auto`;
            canvas.style.maxWidth = `${targetW}px`;
            canvas.style.maxHeight = `${targetH}px`;

            calculateScaleFactor();
            drawMeme();
        };
        img.onerror = () => {
            state.currentTemplate = null;
            console.error("Could not load template image:", url);

            // Set to a default square size if image fails to load for layout purposes
            canvas.width = 600;
            canvas.height = 600;
            canvas.style.maxWidth = '600px';
            canvas.style.maxHeight = '600px';

            calculateScaleFactor();
            drawMeme();
        }
        img.src = url;
    }

    // --- CANVAS LOGIC: DRAWING ---

    function drawMeme() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.currentTemplate) {
            // Draw template scaled to canvas dimensions
            ctx.drawImage(state.currentTemplate, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#94a3b8';
            ctx.font = '30px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('Template Missing or Failed to Load from /memes/', canvas.width / 2, canvas.height / 2);
            return;
        }

        // Draw all Layers
        state.layers.forEach((layer, index) => {
            const isSelected = index === state.selectedLayerIndex;
            if (layer.type === 'text') {
                drawTextLayer(layer, isSelected);
            } else if (layer.type === 'image' && layer.imageObject) {
                drawImageLayer(layer, isSelected);
            }
        });
    }

    // --- Draw Image Layer (Sticker) ---
    function drawImageLayer(layer, isSelected) {
        if (!layer.imageObject) return;

        const scale = layer.scale;
        // Scale relative to an 800px base for consistent scaling
        const drawW = layer.originalW * scale * (canvas.width / 800);
        const drawH = layer.originalH * scale * (canvas.height / 600);

        // Bounding box calculation for hit testing (before rotation)
        // Draw position for un-transformed image
        const x = layer.x - drawW / 2;
        const y = layer.y - drawH / 2;

        // Save the default canvas state
        ctx.save();

        // 1. Move origin to the layer's center point
        ctx.translate(layer.x, layer.y);

        // 2. Apply rotation (convert degrees to radians)
        ctx.rotate(layer.rotation * Math.PI / 180);

        // 3. Apply flip/mirroring
        const flipX = layer.flipX ? -1 : 1;
        const flipY = layer.flipY ? -1 : 1;
        ctx.scale(flipX, flipY);

        // 4. Draw the image at the new origin (which is its center, -drawW/2, -drawH/2)
        ctx.drawImage(layer.imageObject, -drawW / 2, -drawH / 2, drawW, drawH);

        // Update Bounding Box for Hit Testing (using non-rotated, simplified box)
        const padding = 5;
        layer.bbox = {
            x: x - padding,
            y: y - padding,
            w: drawW + (padding * 2),
            h: drawH + (padding * 2),
            centerX: layer.x,
            centerY: layer.y,
            rotation: layer.rotation
        };

        // 5. Draw Selection Box (only if selected)
        if (isSelected) {
            // Restore scale/rotation, but keep translate for drawing the selection box
            ctx.restore();
            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation * Math.PI / 180);

            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;

            // Draw selection box around the un-flipped/un-rotated visual space (relative to origin)
            ctx.strokeRect(-drawW / 2 - padding, -drawH / 2 - padding, drawW + (padding * 2), drawH + (padding * 2));
            ctx.setLineDash([]);
        }

        // Restore canvas state to defaults
        ctx.restore();
    }

    // --- Draw Text Layer ---
    function drawTextLayer(layer, isSelected) {
        const fontObj = fonts.find(f => f.id === layer.fontId);
        const fontBase = fontObj ? fontObj.family : fonts[0].family;

        let fontStyle = layer.isBold ? '900' : 'normal';
        if (layer.isItalic) fontStyle += ' italic';

        ctx.font = `${fontStyle} ${layer.fontSize}px ${fontBase}, ${fontObj.fallback}`;

        const maxWidth = canvas.width * 0.95;
        const lines = getLines(ctx, layer.content.toUpperCase(), maxWidth);
        const lineHeight = layer.fontSize * 1.2;
        const totalTextHeight = lines.length * lineHeight;

        let maxLineWidth = 0;
        lines.forEach(line => {
            const width = ctx.measureText(line).width;
            if (width > maxLineWidth) maxLineWidth = width;
        });

        // Bounding box calculation for hit testing (before rotation)
        const padding = 10;
        layer.bbox = {
            x: layer.x - (maxLineWidth / 2) - padding,
            y: layer.y - (totalTextHeight / 2) - padding,
            w: maxLineWidth + (padding * 2),
            h: totalTextHeight + (padding * 2),
            centerX: layer.x,
            centerY: layer.y,
            rotation: layer.rotation
        };

        // Save the default canvas state
        ctx.save();

        // 1. Move origin to the layer's center point
        ctx.translate(layer.x, layer.y);

        // 2. Apply rotation (convert degrees to radians)
        ctx.rotate(layer.rotation * Math.PI / 180);

        // 3. Apply flip/mirroring
        const flipX = layer.flipX ? -1 : 1;
        const flipY = layer.flipY ? -1 : 1;
        ctx.scale(flipX, flipY);

        // Set drawing styles (applied after scale/rotate)
        ctx.strokeStyle = 'black';
        ctx.lineWidth = Math.floor(layer.fontSize * 0.08);
        ctx.fillStyle = layer.color || 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Draw the text (relative to the new, translated origin)
        let currentY = -(totalTextHeight / 2) + (lineHeight / 2);
        lines.forEach((line) => {
            ctx.strokeText(line, 0, currentY); // 0, 0 is the center of the bounding box
            ctx.fillText(line, 0, currentY);
            currentY += lineHeight;
        });

        // 4. Draw Selection Box (only if selected)
        if (isSelected) {
            // Selection box is drawn *after* scale and rotate, so it follows the text
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;

            // Draw selection box relative to the transformed origin (0,0)
            ctx.strokeRect(
                -maxLineWidth / 2 - padding,
                -totalTextHeight / 2 - padding,
                maxLineWidth + (padding * 2),
                totalTextHeight + (padding * 2)
            );
            ctx.setLineDash([]);
        }

        // Restore canvas state to defaults
        ctx.restore();
    }

    function getLines(ctx, text, maxWidth) {
        const words = text.split(" ");
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            // Measure text using the correct font settings before transformation is applied
            ctx.save();
            ctx.font = ctx.font; // Reapply font settings to ctx (needed if called from drawMeme)
            const width = ctx.measureText(currentLine + " " + word).width;
            ctx.restore();

            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    // --- CANVAS LOGIC: DRAG & DROP (Unified) ---

    function getEventLocation(event) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else if (event.clientX !== undefined) {
            clientX = event.clientX;
            clientY = event.clientY;
        } else {
            return null;
        }

        return {
            x: (clientX - rect.left) * state.scaleFactor,
            y: (clientY - rect.top) * state.scaleFactor
        };
    }

    function setupCanvasInteractions() {
        const startEvents = ['mousedown', 'touchstart'];
        const moveEvents = ['mousemove', 'touchmove'];
        const endEvents = ['mouseup', 'touchend', 'touchcancel'];

        startEvents.forEach(eventName => canvas.addEventListener(eventName, handleStart, false));
        moveEvents.forEach(eventName => canvas.addEventListener(eventName, handleMove, false));
        endEvents.forEach(eventName => canvas.addEventListener(eventName, handleEnd, false));
    }

    // Helper function to check if a point is inside a bounding box (without rotation check for simplicity)
    function checkHit(loc, bbox) {
        // Check based on the simplified, non-rotated box for easier hit detection
        return loc.x >= bbox.x && loc.x <= bbox.x + bbox.w &&
            loc.y >= bbox.y && loc.y <= bbox.y + bbox.h;
    }

    function handleStart(event) {
        event.preventDefault();
        const loc = getEventLocation(event);
        if (!loc) return;

        let hitIndex = -1;
        // Iterate layers in reverse order (topmost layer first)
        for (let i = state.layers.length - 1; i >= 0; i--) {
            const layer = state.layers[i];

            if (checkHit(loc, layer.bbox)) {
                hitIndex = i;
                break;
            }
        }

        state.selectedLayerIndex = hitIndex;
        updateControlPanel();
        drawMeme();

        if (hitIndex !== -1) {
            state.isDragging = true;
            // Calculate drag offset from the layer's center point
            state.dragStartX = loc.x - state.layers[hitIndex].x;
            state.dragStartY = loc.y - state.layers[hitIndex].y;
        }
    }

    function handleMove(event) {
        if (!state.isDragging || state.selectedLayerIndex < 0) return;
        event.preventDefault();

        const loc = getEventLocation(event);
        if (!loc) return;

        const layer = state.layers[state.selectedLayerIndex];

        // Calculate new center point for the layer
        let newX = loc.x - state.dragStartX;
        let newY = loc.y - state.dragStartY;

        // Constrain movement to canvas bounds
        newX = Math.max(0, Math.min(newX, canvas.width));
        newY = Math.max(0, Math.min(newY, canvas.height));

        layer.x = newX;
        layer.y = newY;

        drawMeme();
    }

    function handleEnd(event) {
        if (state.isDragging) {
            event.preventDefault();
            state.isDragging = false;
            drawMeme();
        }
    }

    // --- DOWNLOAD FUNCTION ---

    function downloadMeme() {
        if (!state.currentTemplate) {
            console.error('Download Error: Please select a Template first.');
            return;
        }

        const originalSelection = state.selectedLayerIndex;
        // Clear selection before download to remove boundary box
        state.selectedLayerIndex = -1;
        drawMeme();

        const dataURL = canvas.toDataURL('image/png');

        // Restore selection state
        state.selectedLayerIndex = originalSelection;
        drawMeme();

        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'BaseMeme_' + Date.now() + '.png';

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
</script>

</body>
</html>